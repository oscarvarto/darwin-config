#!/usr/bin/env bash

# Script to toggle home-manager Emacs service on macOS
# Useful for troubleshooting Emacs configuration issues

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Get the launchd service name
SERVICE_NAME="org.nix-community.home.emacs"
PLIST_PATH="$HOME/Library/LaunchAgents/${SERVICE_NAME}.plist"
GUI_DOMAIN="gui/$(id -u)"
LOG_PATH="/tmp/emacs-daemon.log"

# Never allow emacsclient to auto-start a background daemon from this script
export ALTERNATE_EDITOR="false"

# Function to print colored messages
print_msg() {
    local color=$1
    local msg=$2
    echo -e "${color}${msg}${NC}"
}

# Function to check service status
# Returns one of: running, stopped, not-loaded
check_status() {
    # Check if service is loaded and enabled first
    local service_loaded=false
    local service_enabled=false

    if launchctl list | grep -q "$SERVICE_NAME"; then
        service_loaded=true
        # Check if service is enabled (look for exit code 0 which means running)
        local exit_code=$(launchctl list | grep "$SERVICE_NAME" | awk '{print $1}')
        if [[ "$exit_code" == "0" ]]; then
            service_enabled=true
        fi
    fi

    # Check if Emacs daemon is actually running via emacsclient
    local daemon_running=false
    if command -v emacsclient >/dev/null 2>&1; then
        if emacsclient -e '(progn (require (quote server)) (server-running-p))' >/dev/null 2>&1; then
            daemon_running=true
        fi
    fi

    # Determine status based on daemon state and service state
    if [[ "$daemon_running" == true && "$service_loaded" == true ]]; then
        echo "running"
    elif [[ "$service_loaded" == true ]]; then
        echo "stopped"
    else
        echo "not-loaded"
    fi
}

# Function to stop the service
stop_service() {
    print_msg "$YELLOW" "🛑 Stopping Emacs service..."

    # First, try to unload the service with -w flag to disable it
    if [[ -f "$PLIST_PATH" ]]; then
        # Prefer modern launchctl flow on recent macOS versions
        launchctl disable "${GUI_DOMAIN}/${SERVICE_NAME}" 2>/dev/null || true
        launchctl bootout "${GUI_DOMAIN}" "$PLIST_PATH" 2>/dev/null || true
        # Fallback to legacy commands for compatibility
        launchctl unload -w "$PLIST_PATH" 2>/dev/null || true
        launchctl unload "$PLIST_PATH" 2>/dev/null || true
        launchctl remove "$SERVICE_NAME" 2>/dev/null || true
    fi

    # Kill any running Emacs daemon processes (all variations)
    pkill -f "emacs.*--.*daemon" 2>/dev/null || true
    pkill -f "emacs.*daemon" 2>/dev/null || true
    pkill -f "Emacs.app" 2>/dev/null || true

    # Wait a moment for processes to terminate
    sleep 2

    # Force kill if still running
    pkill -9 -f "emacs.*--.*daemon" 2>/dev/null || true
    pkill -9 -f "emacs.*daemon" 2>/dev/null || true
    pkill -9 -f "Emacs.app" 2>/dev/null || true

    # Additional wait to ensure processes are terminated
    sleep 1

    # Clean up stale server sockets/lock files (best-effort, safe paths only)
    for dir in "$HOME/.emacs.d/server" "$HOME/.config/emacs/server" "/tmp/emacs$(id -u)"; do
        if [[ -d "$dir" ]]; then
            rm -f "$dir"/server* 2>/dev/null || true
        fi
    done

    print_msg "$GREEN" "✅ Emacs service stopped"
}

# Check whether the daemon log shows a ready signal
log_indicates_ready() {
    local log_file="$LOG_PATH"
    if [[ ! -f "$log_file" ]]; then
        return 1
    fi

    # Match readiness markers emitted by Emacs daemon/server code
    local ready_regex='Emacs daemon is ready|^Starting server at|Server is already running|Server is up and running'
    if grep -Eiq "$ready_regex" "$log_file"; then
        return 0
    fi

    return 1
}

# Function to start the service
start_service() {
    print_msg "$YELLOW" "🚀 Starting Emacs service..."
    
    if [[ ! -f "$PLIST_PATH" ]]; then
        print_msg "$RED" "❌ Service plist not found at $PLIST_PATH"
        print_msg "$YELLOW" "💡 Try rebuilding your Darwin configuration with: ns"
        return 1
    fi
    
    # Load and enable the LaunchAgent using modern launchctl where possible
    # 1) bootstrap (load), 2) enable, 3) kickstart to run immediately
    launchctl bootstrap "${GUI_DOMAIN}" "$PLIST_PATH" 2>/dev/null || true
    launchctl enable "${GUI_DOMAIN}/${SERVICE_NAME}" 2>/dev/null || true
    launchctl kickstart -k "${GUI_DOMAIN}/${SERVICE_NAME}" 2>/dev/null || true

    # Fallback to legacy load if needed
    launchctl load -w "$PLIST_PATH" 2>/dev/null || launchctl load "$PLIST_PATH" 2>/dev/null || true

    local max_wait="${EMACS_STARTUP_TIMEOUT:-180}"
    local start_time warned_about_process
    start_time=$(date +%s)
    warned_about_process=false

    # Poll for daemon availability (default: 180s) so native compilation can finish
    while (( $(date +%s) - start_time < max_wait )); do
        # Primary check: emacsclient connectivity
        if command -v emacsclient >/dev/null 2>&1; then
            if emacsclient -e '(progn (require (quote server)) (server-running-p))' >/dev/null 2>&1; then
                print_msg "$GREEN" "✅ Emacs service started successfully"
                return 0
            fi
        fi

        # Secondary check: daemon log reports readiness
        if log_indicates_ready; then
            print_msg "$GREEN" "✅ Emacs daemon log reports server ready"
            return 0
        fi

        # Tertiary check: server socket file exists
        for dir in "$HOME/.emacs.d/server" "$HOME/.config/emacs/server" "/tmp/emacs$(id -u)"; do
            if [[ -S "$dir/server" ]]; then
                print_msg "$GREEN" "✅ Emacs server socket detected"
                return 0
            fi
        done

        # If we get here the daemon is still warming up; ensure the process is alive
        if pgrep -f "Emacs\\.app|--fg-daemon" >/dev/null 2>&1; then
            warned_about_process=false
        else
            if [[ "$warned_about_process" == false ]]; then
                print_msg "$YELLOW" "⏳ Waiting for Emacs daemon process to appear..."
                warned_about_process=true
            fi
        fi

        sleep 1
    done

    print_msg "$RED" "⚠️  Service may not have started properly (timeout after ${max_wait}s). Check logs with:"
    print_msg "$BLUE" "   log show --predicate 'process == \"Emacs\" || process == \"emacs\"' --last 5m"
    print_msg "$BLUE" "   tail -n +1 /tmp/emacs-daemon.log 2>/dev/null | tail -n 200"
    return 1
}

# Function to restart the service
restart_service() {
    stop_service
    sleep 1
    start_service
}

# Function to show service info
show_info() {
    local status=$(check_status)
    
    print_msg "$BLUE" "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    print_msg "$BLUE" "  Emacs Service Information"
    print_msg "$BLUE" "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
    
    case "$status" in
        "running")
            print_msg "$GREEN" "📍 Status: Running"
            ;;
        "stopped")
            print_msg "$YELLOW" "📍 Status: Stopped (loaded but not running)"
            ;;
        "not-loaded")
            print_msg "$RED" "📍 Status: Not loaded"
            ;;
    esac
    
    if [[ -f "$PLIST_PATH" ]]; then
        print_msg "$GREEN" "📄 Plist: Found at $PLIST_PATH"
    else
        print_msg "$RED" "📄 Plist: Not found"
    fi
    
    # Check for running Emacs processes
    local emacs_procs=$(pgrep -f "emacs" 2>/dev/null | wc -l | tr -d ' ')
    if [[ "$emacs_procs" -gt 0 ]]; then
        print_msg "$BLUE" "🔧 Running Emacs processes: $emacs_procs"
        echo ""
        ps aux | grep -E "[e]macs" | head -5
    else
        print_msg "$BLUE" "🔧 No Emacs processes running"
    fi
    
    print_msg "$BLUE" "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
}

# Function to show usage
show_usage() {
    cat << EOF
Usage: $(basename "$0") [COMMAND]

Manage the home-manager Emacs service on macOS.

Commands:
  status    Show current service status
  start     Start the Emacs service
  stop      Stop the Emacs service
  restart   Restart the Emacs service
  info      Show detailed service information
  help      Show this help message

Examples:
  $(basename "$0") status    # Check if service is running
  $(basename "$0") stop      # Stop service for troubleshooting
  $(basename "$0") start     # Start service after fixing config
  $(basename "$0") restart   # Quick restart

Note: After making changes to Emacs configuration, you may need to:
  1. Stop the service: $(basename "$0") stop
  2. Rebuild Darwin config: ns
  3. Start the service: $(basename "$0") start

EOF
}

# Main script logic
main() {
    local cmd="${1:-help}"
    
    case "$cmd" in
        status)
            local status=$(check_status)
            case "$status" in
                "running")
                    print_msg "$GREEN" "✅ Emacs service is running"
                    ;;
                "stopped")
                    print_msg "$YELLOW" "⏸️  Emacs service is stopped"
                    ;;
                "not-loaded")
                    print_msg "$RED" "❌ Emacs service is not loaded"
                    ;;
            esac
            ;;
        start)
            start_service
            ;;
        stop)
            stop_service
            ;;
        restart)
            restart_service
            ;;
        info)
            show_info
            ;;
        help|--help|-h)
            show_usage
            ;;
        *)
            print_msg "$RED" "❌ Unknown command: $cmd"
            echo ""
            show_usage
            exit 1
            ;;
    esac
}

# Run the main function
main "$@"
