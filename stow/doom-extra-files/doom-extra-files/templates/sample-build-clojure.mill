// Sample build.mill file for a Clojure project using Mill
// Save this as build.mill in your project root

// Import the ClojureModule trait - adjust the path as needed
import $file.mill_clojure_module
import mill_clojure_module._

// Define your project module
object app extends ClojureModule {
  // Specify the Clojure version
  override def clojureVersion = "1.11.1"
  
  // Add project-specific dependencies
  override def ivyDeps = super.ivyDeps() ++ Agg(
    // Core dependencies
    ivy"org.clojure:core.async:1.6.673",
    
    // REPL/development dependencies
    ivy"nrepl:nrepl:1.0.0",
    ivy"cider:cider-nrepl:0.28.7",
    
    // Web dependencies (example)
    ivy"compojure:compojure:1.7.0",
    ivy"ring:ring-jetty-adapter:1.9.6",
    
    // Database dependencies (example)
    ivy"com.github.seancorfield:next.jdbc:1.3.894"
  )
  
  // Define test module
  object test extends Tests {
    // Inherit from ClojureModule to get Clojure support in tests
    trait Tests extends TestModule {
      // Test-specific dependencies
      def ivyDeps = super.ivyDeps() ++ Agg(
        ivy"io.github.cognitect-labs:test-runner:0.5.1"
      )
    }
    
    // Define test task
    def testTask = T.command {
      mill.scalalib.TestRunner.runTests(
        Seq(), 
        Seq()
      )
      // This is just a placeholder - in practice, we'd use the clojureTest 
      // task from the ClojureModule trait
    }
  }
}

// Additional modules for larger projects (example)
object web extends ClojureModule {
  override def moduleDeps = Seq(app)
  
  override def ivyDeps = super.ivyDeps() ++ Agg(
    ivy"hiccup:hiccup:2.0.0-RC1"
  )
}

// Utility module for shared code
object utils extends ClojureModule {
  // Minimal dependencies module that other modules can depend on
}

// Deployment module with custom tasks
object deploy extends ClojureModule {
  def moduleDeps = Seq(app, web)
  
  // Example custom deployment task
  def uberjar = T {
    // Create an uberjar for deployment
    T.dest
  }
}
